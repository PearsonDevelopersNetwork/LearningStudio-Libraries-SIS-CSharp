#region License Information
// LearningStudio SIS API Libraries 
// These libraries make it easier to use the LearningStudio SIS APIs.
// Full Documentation is provided with the library. 
// 
// Need Help or Have Questions? 
// Please use the PDN Developer Community at https://community.pdn.pearson.com
//
// @category   LearningStudio SIS APIs
// @author     Jason Bradley <richard.bradley@pearson.com>
// @author     Pearson Developer Services Team <apisupport@pearson.com>
// @copyright  2015 Pearson Education Inc.
// @license    http://www.apache.org/licenses/LICENSE-2.0  Apache 2.0
// @version    1.0
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#endregion License Information

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.ServiceModel.Channels;
using System.Text;
using System.Xml;

namespace Com.Pearson.Pdn.Learningstudio.SIS.Users.WCFHelper
{
    /// <summary>
    /// Custom MessageHeader class used to override the default WCF generated SOAP Security Header.
    /// This is required for interoperability between a WCF Client and a WSE 2.0 Service that
    /// implements UsernameToken security using a PasswordDiget.
    /// </summary>
    public class SecurityHeader : MessageHeader
    {
        private APIConfig config;

        /// <summary>
        /// Constructors a new SecurityHeader
        /// </summary>
        /// <param name="config"><see cref="APIConfig"/></param>
        public SecurityHeader(APIConfig config)
        {
            this.config = config;
        }

        /// <summary>
        /// Gets or sets a value that indicates whether the header must be understood, according to SOAP 1.1/1.2 specification.
        /// </summary>
        public override bool MustUnderstand
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets the name of the message header.
        /// </summary>
        public override string Name
        {
            get
            {
                return "Security";
            }
        }

        /// <summary>
        /// Gets the namespace of the message header.
        /// </summary>
        public override string Namespace
        {
            get
            {
                return "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
            }
        }

        /// <summary>
        /// Called when the header content is serialized using the specified XML writer.
        /// </summary>
        /// <param name="writer"><see cref="XmlDictionaryWriter"/></param>
        /// <param name="messageVersion"><see cref="MessageVersion"/></param>
        protected override void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion)
        {
            WriteHeader(writer);
        }

        /// <summary>
        /// Overwrites the default SOAP Security Header values generated by WCF with
        /// those required by the UserService which implements WSE 2.0.  This is required
        /// for interoperability between a WCF Client and a WSE 2.0 Service.
        /// </summary>
        /// <param name="writer"><see cref="XmlDictionaryWriter"/></param>
        private void WriteHeader(XmlDictionaryWriter writer)
        {
            // Create the Nonce
            byte[] nonce = GenerateNonce();

            // Create the Created Date
            string created = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");

            // Create the WSSE Security Header, starting with the Username Element
            writer.WriteStartElement("wsse", "UsernameToken", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
            writer.WriteXmlnsAttribute("wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
            writer.WriteStartElement("wsse", "Username", null);
            writer.WriteString(config.Username);
            writer.WriteEndElement();

            // Add the Password Element
            writer.WriteStartElement("wsse", "Password", null);
            writer.WriteAttributeString("Type", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest");
            writer.WriteString(GeneratePasswordDigest(nonce, created, config.Password));
            writer.WriteEndElement();

            // Add the Nonce Element
            writer.WriteStartElement("wsse", "Nonce", null);
            writer.WriteAttributeString("EncodingType", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary");
            writer.WriteBase64(nonce, 0, nonce.Length);
            writer.WriteEndElement();

            // Lastly, add the Created Element
            writer.WriteStartElement("wsu", "Created", null);
            writer.WriteString(created);
            writer.WriteEndElement();
            writer.WriteEndElement();
            writer.Flush();
        }

        /// <summary>
        /// Generates a random Nonce for encryption purposes
        /// </summary>
        /// <returns>byte[]</returns>
        private byte[] GenerateNonce()
        {
            RNGCryptoServiceProvider rand = new RNGCryptoServiceProvider();
            byte[] buf = new byte[0x10];
            rand.GetBytes(buf);

            return buf;
        }

        /// <summary>
        /// Generates the PasswordDigest using a SHA1 Hash
        /// </summary>
        /// <param name="nonceBytes">byte[]</param>
        /// <param name="created">string</param>
        /// <param name="password">string</param>
        /// <returns>string</returns>
        private string GeneratePasswordDigest(byte[] nonceBytes, string created, string password)
        {
            // Convert the values to be hashed to bytes
            byte[] createdBytes = Encoding.UTF8.GetBytes(created);
            byte[] passwordBytes = Encoding.UTF8.GetBytes(password);
            byte[] msgBytes = new byte[nonceBytes.Length + createdBytes.Length + passwordBytes.Length];

            // Combine the values into one byte array
            Array.Copy(nonceBytes, msgBytes, nonceBytes.Length);
            Array.Copy(createdBytes, 0, msgBytes, nonceBytes.Length, createdBytes.Length);
            Array.Copy(passwordBytes, 0, msgBytes, (nonceBytes.Length + createdBytes.Length), passwordBytes.Length);

            // Generate the hash
            SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider();
            byte[] hashBytes = sha1.ComputeHash(msgBytes);
            return Convert.ToBase64String(hashBytes);
        }
    }
}
